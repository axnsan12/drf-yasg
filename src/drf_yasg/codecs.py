import copy
import json
import logging
from collections import OrderedDict
from io import StringIO

from django.utils.encoding import force_bytes
from ruamel.yaml import YAML
from ruamel.yaml.representer import SafeRepresenter

from . import openapi
from .errors import SwaggerValidationError

logger = logging.getLogger(__name__)


def _validate_flex(spec):
    try:
        from flex.core import parse as validate_flex
        from flex.exceptions import ValidationError
    except ImportError:
        return

    try:
        validate_flex(spec)
    except ValidationError as ex:
        raise SwaggerValidationError(str(ex)) from ex


def _validate_swagger_spec_validator(spec):
    from swagger_spec_validator.common import SwaggerValidationError as SSVErr
    from swagger_spec_validator.validator20 import validate_spec as validate_ssv
    try:
        validate_ssv(spec)
    except SSVErr as ex:
        raise SwaggerValidationError(str(ex)) from ex


#:
VALIDATORS = {
    'flex': _validate_flex,
    'ssv': _validate_swagger_spec_validator,
}


class _OpenAPICodec(object):
    media_type = None

    def __init__(self, validators):
        self._validators = validators

    @property
    def validators(self):
        """List of validator names to apply"""
        return self._validators

    def encode(self, document):
        """Transform an :class:`.Swagger` object to a sequence of bytes.

        Also performs validation and applies settings.

        :param openapi.Swagger document: Swagger spec object as generated by :class:`.OpenAPISchemaGenerator`
        :return: binary encoding of ``document``
        :rtype: bytes
        """
        if not isinstance(document, openapi.Swagger):
            raise TypeError('Expected a `openapi.Swagger` instance')

        spec = self.generate_swagger_object(document)
        errors = {}
        for validator in self.validators:
            try:
                # validate a deepcopy of the spec to prevent the validator from messing with it
                # for example, swagger_spec_validator adds an x-scope property to all references
                VALIDATORS[validator](copy.deepcopy(spec))
            except SwaggerValidationError as e:
                errors[validator] = str(e)

        if errors:
            exc = SwaggerValidationError("spec validation failed: {}".format(errors), errors, spec, self)
            logger.warning(str(exc))
            raise exc

        return force_bytes(self._dump_dict(spec))

    def encode_error(self, err):
        """Dump an error message into an encoding-appropriate sequence of bytes"""
        return force_bytes(self._dump_dict(err))

    def _dump_dict(self, spec):
        """Dump the given dictionary into its string representation.

        :param dict spec: a python dict
        :return: string representation of ``spec``
        :rtype: str or bytes
        """
        raise NotImplementedError("override this method")

    def generate_swagger_object(self, swagger):
        """Generates the root Swagger object.

        :param openapi.Swagger swagger: Swagger spec object as generated by :class:`.OpenAPISchemaGenerator`
        :return: swagger spec as dict
        :rtype: OrderedDict
        """
        return swagger.as_odict()


class OpenAPICodecJson(_OpenAPICodec):
    media_type = 'application/json'

    def __init__(self, validators, pretty=False, media_type='application/json'):
        super(OpenAPICodecJson, self).__init__(validators)
        self.pretty = pretty
        self.media_type = media_type

    def _dump_dict(self, spec):
        """Dump ``spec`` into JSON.

        :rtype: str"""
        if self.pretty:
            out = json.dumps(spec, indent=4, separators=(',', ': '))
            if out[-1] != '\n':
                out += '\n'
            return out
        else:
            return json.dumps(spec)


class SaneYamlRepresenter(SafeRepresenter):
    """SafeRepresenter class usable for dumping ``OrderedDict`` and list instances in a standard way."""

    def ignore_aliases(self, data):
        """Disable YAML references."""
        return True

    def represent_text(self, text):
        """Write multi-line strings in block style."""
        if "\n" in text:
            return self.represent_scalar("tag:yaml.org,2002:str", text, style="|")
        return self.represent_scalar("tag:yaml.org,2002:str", text)


# Use block style for multi-line strings
SaneYamlRepresenter.add_representer(str, SaneYamlRepresenter.represent_text)


# Avoid YAML !!omap tag for OrderedDict
SaneYamlRepresenter.add_representer(OrderedDict, SaneYamlRepresenter.represent_dict)
SaneYamlRepresenter.add_multi_representer(OrderedDict, SaneYamlRepresenter.represent_dict)

yaml = YAML(typ="safe")
yaml.Representer = SaneYamlRepresenter

# Add 2 extra spaces when indenting lists
# https://stackoverflow.com/q/25108581/10612
yaml.indent(sequence=4, offset=2)

# Do not sort dicts by keys in Representer.represent_dict
sort_base_mapping_type_on_output = False


def yaml_sane_dump(data, binary):
    """Dump the given data dictionary into a sane format:

        * OrderedDicts are dumped as regular mappings instead of non-standard !!odict
        * multi-line mapping style instead of json-like inline style
        * list elements are indented into their parents
        * YAML references/aliases are disabled

    :param dict data: the data to be dumped
    :param bool binary: True to return a utf-8 encoded binary object, False to return a string
    :return: the serialized YAML
    :rtype: str or bytes
    """
    out = StringIO()
    yaml.dump(data, stream=out)
    contents = out.getvalue()
    out.close()
    if binary:
        return contents.encode()
    return contents


def yaml_sane_load(stream):
    """Load the given YAML stream while preserving the input order for mapping items.

    :param stream: YAML stream (can be a string or a file-like object)
    :rtype: OrderedDict
    """
    return yaml.load(stream)


class OpenAPICodecYaml(_OpenAPICodec):
    media_type = 'application/yaml'

    def __init__(self, validators, media_type='application/yaml'):
        super(OpenAPICodecYaml, self).__init__(validators)
        self.media_type = media_type

    def _dump_dict(self, spec):
        """Dump ``spec`` into YAML.

        :rtype: bytes"""
        return yaml_sane_dump(spec, binary=True)
